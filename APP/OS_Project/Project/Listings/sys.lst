C51 COMPILER V9.52.0.0   SYS                                                               08/25/2025 16:17:13 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE SYS
OBJECT MODULE PLACED IN ..\Output\sys.obj
COMPILER INVOKED BY: D:\APP\KEIL_V5\MDK\C51\BIN\C51.EXE ..\SYSTEM\sys.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\BSP\Inc
                    -;..\Core\Inc;..\Driver;..\Emembed\Inc;..\SYSTEM) DEBUG OBJECTEXTEND PRINT(.\Listings\sys.lst) TABS(2) OBJECT(..\Output\s
                    -ys.obj)

line level    source

   1          #include "sys.h"
   2          
   3          static uint16_t data SysTick = 0; 
   4          
   5          
   6          //核心寄存器初始化
   7          void sys_cpu_init()
   8          {
   9   1        EA = 0;
  10   1        RS0 = 0;
  11   1        RS1 = 0;
  12   1      
  13   1        CKCON = 0x00;
  14   1        T2CON = 0x70;
  15   1        DPC = 0x00;
  16   1        PAGESEL = 0x01;
  17   1        D_PAGESEL = 0x02; //DATA RAM  0x8000-0xFFFF
  18   1        MUX_SEL = 0x00;   //UART2,UART3关闭，WDT关闭
  19   1        RAMMODE = 0x00;
  20   1        PORTDRV = 0x01;   //驱动强度+/-8mA
  21   1        IEN0 = 0x00;      //关闭所有中断
  22   1        IEN1 = 0x00;
  23   1        IEN2 = 0x00;
  24   1        IP0 = 0x00;       //中断优先级默认
  25   1        IP1 = 0x00;
  26   1      
  27   1        WDT_OFF();        //关闭开门狗
  28   1      }
  29          
  30          //定时器2初始化,定时间隔为1ms
  31          void sys_timer2_init()
  32          {
  33   1        T2CON = 0x70;
  34   1        TH2 = 0x00;
  35   1        TL2 = 0x00;
  36   1      
  37   1        TRL2H = 0xBC; //1ms的定时器
  38   1        TRL2L = 0xCD;       
  39   1      
  40   1        IEN0 |= 0x20; //启动定时器2
  41   1        TR2 = 0x01;
  42   1        EA = 1;
  43   1      }
  44          
  45          //系统初始化
  46          void sys_init()
  47          {
  48   1        sys_cpu_init();//核心寄存器初始化
  49   1        sys_timer2_init();//定时器2初始化
  50   1      }
  51          
  52          // //软件大致延时,单位ms
  53          // //如果修改了优化等级,那么此函数内部的参数需要重新调试
C51 COMPILER V9.52.0.0   SYS                                                               08/25/2025 16:17:13 PAGE 2   

  54          // void sys_delay_about_ms(uint16_t ms)
  55          // {
  56          //  uint16_t i,j;
  57          //  for(i=0;i<ms;i++)
  58          //      for(j=0;j<3000;j++);    
  59          // }
  60          
  61          // //软件大致延时,单位us
  62          // //如果修改了优化等级,那么此函数内部的参数需要重新调试
  63          // void sys_delay_about_us(uint8_t us)
  64          // {
  65          //  uint8_t i,j;
  66          //  for(i=0;i<us;i++)
  67          //      for(j=0;j<5;j++);    
  68          // }
  69          
  70          void delay_ms(uint16_t ms)
  71          {
  72   1          int data mi,mj;
  73   1          for(mi=0;mi<ms;mi++)
  74   1              for(mj=0;mj<18500;mj++);
  75   1      }
  76          
  77          void delay_us(uint16_t us)
  78          {
  79   1          int data ui,uj;
  80   1          for(ui=0;ui<us;ui++)
  81   1              for(uj=0;uj<5;uj++);
  82   1      }
  83          
  84          uint16_t Read_Dgus(uint16_t Dgus_Addr)
  85          {         uint16_t R_Dgus=0;
  86   1      //      EA = 0;
  87   1            ADR_H = 0x00;
  88   1            ADR_M = (uint8_t)((Dgus_Addr/2)>>8);
  89   1            ADR_L = (uint8_t)(Dgus_Addr/2);
  90   1            RAMMODE = 0xAF;   //读操作
  91   1            while(!APP_ACK);
  92   1            APP_EN = 1;
  93   1            while(APP_EN);
  94   1            if(Dgus_Addr%2) R_Dgus = (DATA1<<8)+DATA0; 
  95   1            else   R_Dgus=(DATA3<<8)+DATA2;
  96   1            RAMMODE = 0;
  97   1      //      EA = 1;
  98   1            return   R_Dgus;    
  99   1      }
 100          /****************************************************************************/
 101          void Write_Dgus(uint16_t Dgus_Addr,uint16_t Val)
 102          {          
 103   1      //  EA = 0;
 104   1        ADR_H = 0x00;
 105   1        ADR_M = (uint8_t)((Dgus_Addr/2)>>8);
 106   1        ADR_L = (uint8_t)(Dgus_Addr/2);
 107   1        RAMMODE = 0xAF;   //读操作
 108   1        while(!APP_ACK);
 109   1        APP_EN = 1;
 110   1        while(APP_EN);
 111   1        RAMMODE = 0;
 112   1        ADR_M = (uint8_t)((Dgus_Addr/2)>>8);
 113   1        ADR_L = (uint8_t)(Dgus_Addr/2);
 114   1        RAMMODE = 0x8F;   //写操作
 115   1        while(!APP_ACK);
C51 COMPILER V9.52.0.0   SYS                                                               08/25/2025 16:17:13 PAGE 3   

 116   1        if(Dgus_Addr%2){DATA1=(uint8_t)(Val>>8); DATA0=(uint8_t)(Val); }
 117   1        else { DATA3 =(uint8_t)(Val>>8);  DATA2 =(uint8_t)(Val);}
 118   1        APP_EN = 1;
 119   1        while(APP_EN);
 120   1        RAMMODE = 0;
 121   1      //  EA = 1;
 122   1      }
 123          
 124          //读DGUS中的VP变量数据
 125          //addr:就是直接传入DGUS中的地址
 126          //buf:缓冲区
 127          //len:读取的字数,一个字等于2个字节
 128          void sys_read_vp(uint16_t addr,uint8_t* buf,uint16_t len)
 129          {   
 130   1        uint8_t i; 
 131   1        
 132   1        i = (uint8_t)(addr&0x01);
 133   1        addr >>= 1;
 134   1        ADR_H = 0x00;
 135   1        ADR_M = (uint8_t)(addr>>8);
 136   1        ADR_L = (uint8_t)addr;
 137   1        ADR_INC = 0x01;
 138   1        RAMMODE = 0xAF;
 139   1        while(APP_ACK==0);
 140   1        while(len>0)
 141   1        {   
 142   2          APP_EN=1;
 143   2          while(APP_EN==1);
 144   2          if((i==0)&&(len>0))   
 145   2          {   
 146   3            *buf++ = DATA3;
 147   3            *buf++ = DATA2;                      
 148   3            i = 1;
 149   3            len--;  
 150   3          }
 151   2          if((i==1)&&(len>0))   
 152   2          {   
 153   3            *buf++ = DATA1;
 154   3            *buf++ = DATA0;                      
 155   3            i = 0;
 156   3            len--;  
 157   3          }
 158   2        }
 159   1        RAMMODE = 0x00;
 160   1      }
 161          
 162          //写DGUS中的VP变量数据
 163          //addr:就是直接传入DGUS中的地址
 164          //buf:缓冲区
 165          //len:被发送数据的字数,一个字等于2个字节
 166          void sys_write_vp(uint16_t addr,uint8_t* buf,uint16_t len)
 167          {   
 168   1        uint8_t i;  
 169   1        
 170   1        i = (uint8_t)(addr&0x01);
 171   1        addr >>= 1;
 172   1        ADR_H = 0x00;
 173   1        ADR_M = (uint8_t)(addr>>8);
 174   1        ADR_L = (uint8_t)addr;    
 175   1        ADR_INC = 0x01;
 176   1        RAMMODE = 0x8F;
 177   1        while(APP_ACK==0);
C51 COMPILER V9.52.0.0   SYS                                                               08/25/2025 16:17:13 PAGE 4   

 178   1        if(i && len>0)
 179   1        { 
 180   2          RAMMODE = 0x83; 
 181   2          DATA1 = *buf++;   
 182   2          DATA0 = *buf++; 
 183   2          APP_EN = 1;   
 184   2          len--;
 185   2        }
 186   1        RAMMODE = 0x8F;
 187   1        while(len>=2)
 188   1        { 
 189   2          DATA3 = *buf++;   
 190   2          DATA2 = *buf++;
 191   2          DATA1 = *buf++;   
 192   2          DATA0 = *buf++;
 193   2          APP_EN = 1;   
 194   2          len -= 2;
 195   2        }
 196   1        if(len)
 197   1        { 
 198   2          RAMMODE = 0x8C;
 199   2          DATA3 = *buf++;   
 200   2          DATA2 = *buf++;
 201   2          APP_EN = 1;
 202   2        }
 203   1        RAMMODE = 0x00;
 204   1      } 
 205          
 206          /*****************************************************************************/
 207          void Write_Dgusii_Vp_byChar(unsigned int addr,unsigned char *buf,unsigned int len)
 208          {
 209   1        unsigned char i;
 210   1      //  bit EA_Bak;
 211   1      //  EA_Bak = EA;
 212   1      //  EA = 0;
 213   1        i = (unsigned char)(addr & 0x01);
 214   1        addr = addr / 2;
 215   1        ADR_H = 0x00;
 216   1        ADR_M = (unsigned char)(addr >> 8);
 217   1        ADR_L = (unsigned char)(addr);
 218   1        ADR_INC = 0x01;
 219   1        RAMMODE = 0x8F;
 220   1        while(APP_ACK == 0);
 221   1        if(i && len > 0){
 222   2          if(len == 1){
 223   3            RAMMODE = 0x82;
 224   3            DATA1 = *buf++;
 225   3            APP_EN = 1;
 226   3            while(APP_EN == 1);
 227   3            len--;
 228   3          } else {
 229   3            RAMMODE = 0x83;
 230   3            DATA1 = *buf++;
 231   3            DATA0 = *buf++;
 232   3            APP_EN = 1;
 233   3            while(APP_EN == 1);
 234   3            len -= 2;
 235   3          }
 236   2        }
 237   1        RAMMODE = 0x8F;
 238   1        while(len >= 4){
 239   2          DATA3 = *buf++;
C51 COMPILER V9.52.0.0   SYS                                                               08/25/2025 16:17:13 PAGE 5   

 240   2          DATA2 = *buf++;
 241   2          DATA1 = *buf++;
 242   2          DATA0 = *buf++;
 243   2          APP_EN = 1;
 244   2          while(APP_EN == 1);
 245   2          len -= 4;
 246   2        }
 247   1        
 248   1        if(len == 3){
 249   2          RAMMODE = 0x8E;
 250   2          DATA3 = *buf++;
 251   2          DATA2 = *buf++;
 252   2          DATA1 = *buf++;
 253   2          APP_EN = 1;
 254   2          while(APP_EN == 1);
 255   2        } else if(len == 2){
 256   2          RAMMODE = 0x8C;
 257   2          DATA3 =* buf++;
 258   2          DATA2 =* buf++;
 259   2          APP_EN = 1;
 260   2          while(APP_EN == 1);
 261   2        } else if(len == 1){
 262   2          RAMMODE = 0x88;
 263   2          DATA3 = *buf++;
 264   2          APP_EN = 1;
 265   2          while(APP_EN == 1);
 266   2        }
 267   1        RAMMODE = 0x00;
 268   1      //  EA = EA_Bak;
 269   1      }
 270          
 271          //定时器2中断服务程序
 272          void sys_timer2_isr() interrupt 5
 273          {
 274   1          TF2=0;    
 275   1          SysTick--; 
 276   1          WDT_RST(); 
 277   1      }
 278          
 279          
 280          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1333    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      21
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
