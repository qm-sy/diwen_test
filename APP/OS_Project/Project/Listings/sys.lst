C51 COMPILER V9.60.7.0   SYS                                                               08/25/2025 22:37:01 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SYS
OBJECT MODULE PLACED IN ..\Output\sys.obj
COMPILER INVOKED BY: D:\APP\KEIL\MDK\C51\BIN\C51.EXE ..\SYSTEM\sys.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\BSP\Inc;..
                    -\Core\Inc;..\Driver;..\Emembed\Inc;..\SYSTEM) DEBUG OBJECTEXTEND PRINT(.\Listings\sys.lst) TABS(2) OBJECT(..\Output\sys.
                    -obj)

line level    source

   1          #include "sys.h"
   2          
   3          static uint16_t data SysTick = 0; 
   4          
   5          
   6          //核心寄存器初始化
   7          void sys_cpu_init()
   8          {
   9   1        EA = 0;
  10   1        RS0 = 0;
  11   1        RS1 = 0;
  12   1      
  13   1        CKCON = 0x00;
  14   1        T2CON = 0x70;
  15   1        DPC = 0x00;
  16   1        PAGESEL = 0x01;
  17   1        D_PAGESEL = 0x02; //DATA RAM  0x8000-0xFFFF
  18   1        MUX_SEL = 0x00;   //UART2,UART3关闭，WDT关闭
  19   1        RAMMODE = 0x00;
  20   1        PORTDRV = 0x01;   //驱动强度+/-8mA
  21   1        IEN0 = 0x00;      //关闭所有中断
  22   1        IEN1 = 0x00;
  23   1        IEN2 = 0x00;
  24   1        IP0 = 0x00;       //中断优先级默认
  25   1        IP1 = 0x00;
  26   1      
  27   1        WDT_OFF();        //关闭开门狗
  28   1      }
  29          
  30          //定时器2初始化,定时间隔为1ms
  31          void sys_timer2_init()
  32          {
  33   1        T2CON = 0x70;
  34   1        TH2 = 0x00;
  35   1        TL2 = 0x00;
  36   1      
  37   1        TRL2H = 0xBC; //1ms的定时器
  38   1        TRL2L = 0xCD;       
  39   1      
  40   1        IEN0 |= 0x20; //启动定时器2
  41   1        TR2 = 0x01;
  42   1      }
  43          
  44          //系统初始化
  45          void sys_init()
  46          {
  47   1        sys_cpu_init();//核心寄存器初始化
  48   1        sys_timer2_init();//定时器2初始化
  49   1      }
  50          
  51          // //软件大致延时,单位ms
  52          // //如果修改了优化等级,那么此函数内部的参数需要重新调试
  53          // void sys_delay_about_ms(uint16_t ms)
C51 COMPILER V9.60.7.0   SYS                                                               08/25/2025 22:37:01 PAGE 2   

  54          // {
  55          //  uint16_t i,j;
  56          //  for(i=0;i<ms;i++)
  57          //      for(j=0;j<3000;j++);    
  58          // }
  59          
  60          // //软件大致延时,单位us
  61          // //如果修改了优化等级,那么此函数内部的参数需要重新调试
  62          // void sys_delay_about_us(uint8_t us)
  63          // {
  64          //  uint8_t i,j;
  65          //  for(i=0;i<us;i++)
  66          //      for(j=0;j<5;j++);    
  67          // }
  68          
  69          void delay_ms(uint16_t ms)
  70          {
  71   1          int data mi,mj;
  72   1          for(mi=0;mi<ms;mi++)
  73   1              for(mj=0;mj<18500;mj++);
  74   1      }
  75          
  76          void delay_us(uint16_t us)
  77          {
  78   1          int data ui,uj;
  79   1          for(ui=0;ui<us;ui++)
  80   1              for(uj=0;uj<5;uj++);
  81   1      }
  82          
  83          uint16_t Read_Dgus(uint16_t Dgus_Addr)
  84          {         uint16_t R_Dgus=0;
  85   1      //      EA = 0;
  86   1            ADR_H = 0x00;
  87   1            ADR_M = (uint8_t)((Dgus_Addr/2)>>8);
  88   1            ADR_L = (uint8_t)(Dgus_Addr/2);
  89   1            RAMMODE = 0xAF;   //读操作
  90   1            while(!APP_ACK);
  91   1            APP_EN = 1;
  92   1            while(APP_EN);
  93   1            if(Dgus_Addr%2) R_Dgus = (DATA1<<8)+DATA0; 
  94   1            else   R_Dgus=(DATA3<<8)+DATA2;
  95   1            RAMMODE = 0;
  96   1      //      EA = 1;
  97   1            return   R_Dgus;    
  98   1      }
  99          /****************************************************************************/
 100          void Write_Dgus(uint16_t Dgus_Addr,uint16_t Val)
 101          {          
 102   1      //  EA = 0;
 103   1        ADR_H = 0x00;
 104   1        ADR_M = (uint8_t)((Dgus_Addr/2)>>8);
 105   1        ADR_L = (uint8_t)(Dgus_Addr/2);
 106   1        RAMMODE = 0xAF;   //读操作
 107   1        while(!APP_ACK);
 108   1        APP_EN = 1;
 109   1        while(APP_EN);
 110   1        RAMMODE = 0;
 111   1        ADR_M = (uint8_t)((Dgus_Addr/2)>>8);
 112   1        ADR_L = (uint8_t)(Dgus_Addr/2);
 113   1        RAMMODE = 0x8F;   //写操作
 114   1        while(!APP_ACK);
 115   1        if(Dgus_Addr%2){DATA1=(uint8_t)(Val>>8); DATA0=(uint8_t)(Val); }
C51 COMPILER V9.60.7.0   SYS                                                               08/25/2025 22:37:01 PAGE 3   

 116   1        else { DATA3 =(uint8_t)(Val>>8);  DATA2 =(uint8_t)(Val);}
 117   1        APP_EN = 1;
 118   1        while(APP_EN);
 119   1        RAMMODE = 0;
 120   1      //  EA = 1;
 121   1      }
 122          
 123          //读DGUS中的VP变量数据
 124          //addr:就是直接传入DGUS中的地址
 125          //buf:缓冲区
 126          //len:读取的字数,一个字等于2个字节
 127          void sys_read_vp(uint16_t addr,uint8_t* buf,uint16_t len)
 128          {   
 129   1        uint8_t i; 
 130   1        
 131   1        i = (uint8_t)(addr&0x01);
 132   1        addr >>= 1;
 133   1        ADR_H = 0x00;
 134   1        ADR_M = (uint8_t)(addr>>8);
 135   1        ADR_L = (uint8_t)addr;
 136   1        ADR_INC = 0x01;
 137   1        RAMMODE = 0xAF;
 138   1        while(APP_ACK==0);
 139   1        while(len>0)
 140   1        {   
 141   2          APP_EN=1;
 142   2          while(APP_EN==1);
 143   2          if((i==0)&&(len>0))   
 144   2          {   
 145   3            *buf++ = DATA3;
 146   3            *buf++ = DATA2;                      
 147   3            i = 1;
 148   3            len--;  
 149   3          }
 150   2          if((i==1)&&(len>0))   
 151   2          {   
 152   3            *buf++ = DATA1;
 153   3            *buf++ = DATA0;                      
 154   3            i = 0;
 155   3            len--;  
 156   3          }
 157   2        }
 158   1        RAMMODE = 0x00;
 159   1      }
 160          
 161          //写DGUS中的VP变量数据
 162          //addr:就是直接传入DGUS中的地址
 163          //buf:缓冲区
 164          //len:被发送数据的字数,一个字等于2个字节
 165          void sys_write_vp(uint16_t addr,uint8_t* buf,uint16_t len)
 166          {   
 167   1        uint8_t i;  
 168   1        
 169   1        i = (uint8_t)(addr&0x01);
 170   1        addr >>= 1;
 171   1        ADR_H = 0x00;
 172   1        ADR_M = (uint8_t)(addr>>8);
 173   1        ADR_L = (uint8_t)addr;    
 174   1        ADR_INC = 0x01;
 175   1        RAMMODE = 0x8F;
 176   1        while(APP_ACK==0);
 177   1        if(i && len>0)
C51 COMPILER V9.60.7.0   SYS                                                               08/25/2025 22:37:01 PAGE 4   

 178   1        { 
 179   2          RAMMODE = 0x83; 
 180   2          DATA1 = *buf++;   
 181   2          DATA0 = *buf++; 
 182   2          APP_EN = 1;   
 183   2          len--;
 184   2        }
 185   1        RAMMODE = 0x8F;
 186   1        while(len>=2)
 187   1        { 
 188   2          DATA3 = *buf++;   
 189   2          DATA2 = *buf++;
 190   2          DATA1 = *buf++;   
 191   2          DATA0 = *buf++;
 192   2          APP_EN = 1;   
 193   2          len -= 2;
 194   2        }
 195   1        if(len)
 196   1        { 
 197   2          RAMMODE = 0x8C;
 198   2          DATA3 = *buf++;   
 199   2          DATA2 = *buf++;
 200   2          APP_EN = 1;
 201   2        }
 202   1        RAMMODE = 0x00;
 203   1      } 
 204          
 205          /*****************************************************************************/
 206          void Write_Dgusii_Vp_byChar(unsigned int addr,unsigned char *buf,unsigned int len)
 207          {
 208   1        unsigned char i;
 209   1      //  bit EA_Bak;
 210   1      //  EA_Bak = EA;
 211   1      //  EA = 0;
 212   1        i = (unsigned char)(addr & 0x01);
 213   1        addr = addr / 2;
 214   1        ADR_H = 0x00;
 215   1        ADR_M = (unsigned char)(addr >> 8);
 216   1        ADR_L = (unsigned char)(addr);
 217   1        ADR_INC = 0x01;
 218   1        RAMMODE = 0x8F;
 219   1        while(APP_ACK == 0);
 220   1        if(i && len > 0){
 221   2          if(len == 1){
 222   3            RAMMODE = 0x82;
 223   3            DATA1 = *buf++;
 224   3            APP_EN = 1;
 225   3            while(APP_EN == 1);
 226   3            len--;
 227   3          } else {
 228   3            RAMMODE = 0x83;
 229   3            DATA1 = *buf++;
 230   3            DATA0 = *buf++;
 231   3            APP_EN = 1;
 232   3            while(APP_EN == 1);
 233   3            len -= 2;
 234   3          }
 235   2        }
 236   1        RAMMODE = 0x8F;
 237   1        while(len >= 4){
 238   2          DATA3 = *buf++;
 239   2          DATA2 = *buf++;
C51 COMPILER V9.60.7.0   SYS                                                               08/25/2025 22:37:01 PAGE 5   

 240   2          DATA1 = *buf++;
 241   2          DATA0 = *buf++;
 242   2          APP_EN = 1;
 243   2          while(APP_EN == 1);
 244   2          len -= 4;
 245   2        }
 246   1        
 247   1        if(len == 3){
 248   2          RAMMODE = 0x8E;
 249   2          DATA3 = *buf++;
 250   2          DATA2 = *buf++;
 251   2          DATA1 = *buf++;
 252   2          APP_EN = 1;
 253   2          while(APP_EN == 1);
 254   2        } else if(len == 2){
 255   2          RAMMODE = 0x8C;
 256   2          DATA3 =* buf++;
 257   2          DATA2 =* buf++;
 258   2          APP_EN = 1;
 259   2          while(APP_EN == 1);
 260   2        } else if(len == 1){
 261   2          RAMMODE = 0x88;
 262   2          DATA3 = *buf++;
 263   2          APP_EN = 1;
 264   2          while(APP_EN == 1);
 265   2        }
 266   1        RAMMODE = 0x00;
 267   1      //  EA = EA_Bak;
 268   1      }
 269          
 270          //定时器2中断服务程序
 271          void sys_timer2_isr() interrupt 5
 272          {
 273   1          TF2=0;    
 274   1          SysTick--; 
 275   1          WDT_RST(); 
 276   1      }
 277          
 278          
 279          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1331    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      21
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
