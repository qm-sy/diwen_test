C51 COMPILER V9.60.7.0   COMMUNICATION                                                     08/25/2025 22:37:01 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE COMMUNICATION
OBJECT MODULE PLACED IN ..\Output\communication.obj
COMPILER INVOKED BY: D:\APP\KEIL\MDK\C51\BIN\C51.EXE ..\BSP\Src\communication.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..
                    -\BSP\Inc;..\Core\Inc;..\Driver;..\Emembed\Inc;..\SYSTEM) DEBUG OBJECTEXTEND PRINT(.\Listings\communication.lst) TABS(2) 
                    -OBJECT(..\Output\communication.obj)

line level    source

   1          #include "communication.h"
   2          
   3          RS485_2 rs485_2;
   4          RS485_4 rs485_4;
   5          RS485_5 rs485_5;
   6          
   7          /**
   8           * @brief 串口2调用结构体 rs485_2 初始化
   9           *
  10           * @param   
  11           *
  12           * @return  void
  13          **/
  14          void Uart2_Send_Statu_Init( void )
  15          {
  16   1          rs485_2.RX2_rev_end_Flag = 0;
  17   1          rs485_2.TX2_buf[128] = 0;
  18   1          rs485_2.RX2_buf[128] = 0;
  19   1          rs485_2.TX2_send_bytelength = 0;
  20   1          rs485_2.TX2_send_cnt = 0;
  21   1          rs485_2.RX2_rev_timeout = 0;
  22   1          rs485_2.RX2_rev_cnt = 0;
  23   1          //DR_485 = 0;
  24   1      }
  25          
  26          /**
  27           * @brief 串口4调用结构体 rs485_4 初始化
  28           *
  29           * @param   
  30           *
  31           * @return  void
  32          **/
  33          void Uart4_Send_Statu_Init( void )
  34          {
  35   1          rs485_4.RX4_rev_end_Flag = 0;
  36   1          rs485_4.TX4_buf[128] = 0;
  37   1          rs485_4.RX4_buf[128] = 0;
  38   1          rs485_4.TX4_send_bytelength = 0;
  39   1          rs485_4.TX4_send_cnt = 0;
  40   1          rs485_4.RX4_rev_timeout = 0;
  41   1          rs485_4.RX4_rev_cnt = 0;
  42   1          //DR_485 = 0;
  43   1      }
  44          
  45          /**
  46           * @brief 串口5调用结构体 rs485_5 初始化
  47           *
  48           * @param   
  49           *
  50           * @return  void
  51          **/
  52          void Uart5_Send_Statu_Init( void )
  53          {
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     08/25/2025 22:37:01 PAGE 2   

  54   1          rs485_5.RX5_rev_end_Flag = 0;
  55   1          rs485_5.TX5_buf[128] = 0;
  56   1          rs485_5.RX5_buf[128] = 0;
  57   1          rs485_5.TX5_send_bytelength = 0;
  58   1          rs485_5.TX5_send_cnt = 0;
  59   1          rs485_5.RX5_rev_timeout = 0;
  60   1          rs485_5.RX5_rev_cnt = 0;
  61   1          //DR_485 = 0;
  62   1      }
  63          
  64          /**
  65           * @brief 串口4中断处理函数
  66           *
  67           * @param   
  68           *
  69           * @return  void
  70          **/
  71          void Uart2_RXTX_Isr( void ) interrupt 4 
  72          {   
  73   1      
  74   1          /* 1, 检测到S4TI置1，即发送完毕                       */
  75   1          if( TI0 == 1)          //
  76   1          {
  77   2              /* 2, 软件将S4TI清零，等待发送标志位重置，可继续发送    */
  78   2              TI0 = 0;    
  79   2              Busy2 = 0;   
  80   2              /* 3, 依次将TX2_buf中数据送出（写SBUF0操作即为发送）    */
  81   2              if( download_flag == 0 )
  82   2              {
  83   3                  if( rs485_2.TX2_send_bytelength != 0 )
  84   3                  {
  85   4                      SBUF0 = rs485_2.TX2_buf[rs485_2.TX2_send_cnt++];
  86   4                      rs485_2.TX2_send_bytelength--;
  87   4                  }else
  88   3                  {
  89   4                      rs485_2.TX2_send_cnt = 0;
  90   4                      //DR_485 = 0;
  91   4                  }
  92   3              }
  93   2          }
  94   1          
  95   1          /* 1, 检测到S2RI置1，即接收完毕                       */
  96   1          if( RI0 == 1 )
  97   1          {
  98   2              /* 2, 软件将S2RI清零，等待接收标志位重置，可继续发送    */
  99   2              RI0 = 0;
 100   2      
 101   2              R_u2[R_CN2] = SBUF0;
 102   2          R_OD2 = 1;
 103   2          if(R_CN2<UART2_RX_LENTH-1)
 104   2          {
 105   3            R_CN2++;
 106   3          } 
 107   2          T_O2=5; 
 108   2              
 109   2              /* 3, 判断数据包是否接收完毕                           */
 110   2              if( !rs485_2.RX2_rev_end_Flag )
 111   2              {
 112   3                  /* 4, 数据包大于RX_buf 则从头计数                  */
 113   3                  if( rs485_2.RX2_rev_cnt > 128 )
 114   3                  {
 115   4                      rs485_2.RX2_rev_cnt = 0;
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     08/25/2025 22:37:01 PAGE 3   

 116   4                  }
 117   3      
 118   3                  /* 5, 依次将RX2_buf中数据接收（读S2BUF操作即为接收）*/
 119   3                  rs485_2.RX2_buf[rs485_2.RX2_rev_cnt] = SBUF0;
 120   3                  rs485_2.RX2_rev_cnt++;
 121   3              }
 122   2              /* 6, 重置接收完毕判断时间                              */
 123   2              rs485_2.RX2_rev_timeout = 5;
 124   2          }
 125   1      
 126   1      }
 127          
 128          
 129          /**
 130           * @brief 串口4中断处理函数
 131           *
 132           * @param   
 133           *
 134           * @return  void
 135          **/
 136          void Uart4_TX_Isr() interrupt 10 
 137          {   
 138   1          /* 1, 检测到S4TI置1，即发送完毕                       */
 139   1          if( SCON2T & S4TI )          //
 140   1          {
 141   2              /* 2, 软件将S4TI清零，等待发送标志位重置，可继续发送    */
 142   2              SCON2T &= ~S4TI;     
 143   2              /* 3, 依次将TX4_buf中数据送出（写SBUF0操作即为发送）    */
 144   2              if( rs485_4.TX4_send_bytelength != 0 )
 145   2              {
 146   3                  SBUF2_TX = rs485_4.TX4_buf[rs485_4.TX4_send_cnt++];
 147   3                  rs485_4.TX4_send_bytelength--;
 148   3              }else
 149   2              {
 150   3                  rs485_4.TX4_send_cnt = 0;
 151   3                  //DR_485 = 0;
 152   3              }
 153   2          }
 154   1      }
 155          
 156          /**
 157           * @brief 串口4中断处理函数
 158           *
 159           * @param   
 160           *
 161           * @return  void
 162          **/
 163          void Uart4_RX_Isr() interrupt 11 
 164          {   
 165   1              /* 1, 检测到S2RI置1，即接收完毕                       */
 166   1          if( SCON2R & S4RI )
 167   1          {
 168   2              /* 2, 软件将S2RI清零，等待接收标志位重置，可继续发送    */
 169   2              SCON2R &= ~S4RI; 
 170   2              /* 3, 判断数据包是否接收完毕                           */
 171   2              if( !rs485_4.RX4_rev_end_Flag )
 172   2              {
 173   3                  /* 4, 数据包大于RX_buf 则从头计数                  */
 174   3                  if( rs485_4.RX4_rev_cnt > 128 )
 175   3                  {
 176   4                      rs485_4.RX4_rev_cnt = 0;
 177   4                  }
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     08/25/2025 22:37:01 PAGE 4   

 178   3      
 179   3                  /* 5, 依次将RX4_buf中数据接收（读S2BUF操作即为接收）*/
 180   3                  rs485_4.RX4_buf[rs485_4.RX4_rev_cnt] = SBUF2_RX;
 181   3                  rs485_4.RX4_rev_cnt++;
 182   3              }
 183   2              /* 6, 重置接收完毕判断时间                              */
 184   2              rs485_4.RX4_rev_timeout = 5;
 185   2          }
 186   1      }
 187          
 188          
 189          /**
 190           * @brief 串口4中断处理函数
 191           *
 192           * @param   
 193           *
 194           * @return  void
 195          **/
 196          void Uart5_TX_Isr() interrupt 12 
 197          {   
 198   1          /* 1, 检测到S4TI置1，即发送完毕                       */
 199   1          if( SCON3T & S5TI )          //
 200   1          {
 201   2              /* 2, 软件将S4TI清零，等待发送标志位重置，可继续发送    */
 202   2              SCON3T &= ~S5TI;     
 203   2              /* 3, 依次将TX5_buf中数据送出（写SBUF0操作即为发送）    */
 204   2              if( rs485_5.TX5_send_bytelength != 0 )
 205   2              {
 206   3                  SBUF3_TX = rs485_5.TX5_buf[rs485_5.TX5_send_cnt++];
 207   3                  rs485_5.TX5_send_bytelength--;
 208   3              }else
 209   2              {
 210   3                  rs485_5.TX5_send_cnt = 0;
 211   3                  //DR_485 = 0;
 212   3              }
 213   2          }
 214   1      }
 215          
 216          /**
 217           * @brief 串口4中断处理函数
 218           *
 219           * @param   
 220           *
 221           * @return  void
 222          **/
 223          void Uart5_RX_Isr() interrupt 13 
 224          {   
 225   1              /* 1, 检测到S2RI置1，即接收完毕                       */
 226   1          if( SCON3R & S5RI )
 227   1          {
 228   2              /* 2, 软件将S2RI清零，等待接收标志位重置，可继续发送    */
 229   2              SCON3R &= ~S5RI; 
 230   2      
 231   2              /* 3, 判断数据包是否接收完毕                           */
 232   2              if( !rs485_5.RX5_rev_end_Flag )
 233   2              {
 234   3                  /* 4, 数据包大于RX_buf 则从头计数                  */
 235   3                  if( rs485_5.RX5_rev_cnt > 128 )
 236   3                  {
 237   4                      rs485_5.RX5_rev_cnt = 0;
 238   4                  }
 239   3      
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     08/25/2025 22:37:01 PAGE 5   

 240   3                  /* 5, 依次将RX5_buf中数据接收（读S2BUF操作即为接收）*/
 241   3                  rs485_5.RX5_buf[rs485_5.RX5_rev_cnt] = SBUF3_RX;
 242   3                  rs485_5.RX5_rev_cnt++;
 243   3              }
 244   2              /* 6, 重置接收完毕判断时间                              */
 245   2              rs485_5.RX5_rev_timeout = 5;
 246   2          }
 247   1      }
 248          
 249          void Tim1_Isr( void ) interrupt 3
 250          {
 251   1          TH1   = (uint8_t)(T0_PERIOD_1MS>>8);
 252   1          TL1   = (uint8_t)T0_PERIOD_1MS;  
 253   1      
 254   1          /* 1, 如果接收未超时                                             */
 255   1          if ( rs485_2.RX2_rev_timeout != 0 )  
 256   1          {
 257   2              rs485_2.RX2_rev_timeout--;
 258   2              /* 2, 如果接收超时                                          */
 259   2              if( rs485_2.RX2_rev_timeout == 0 )  
 260   2              {
 261   3                  if( rs485_2.RX2_rev_cnt > 0 )  
 262   3                  {   
 263   4                       /* 3, 接收完毕标志位亮起并初始化接收缓冲区         */
 264   4                      rs485_2.RX2_rev_end_Flag = 1;    
 265   4                  }
 266   3              }
 267   2          } 
 268   1      
 269   1              /* 1, 如果接收未超时                                             */
 270   1          if ( rs485_4.RX4_rev_timeout != 0 )  
 271   1          {
 272   2              rs485_4.RX4_rev_timeout--;
 273   2              /* 2, 如果接收超时                                          */
 274   2              if( rs485_4.RX4_rev_timeout == 0 )  
 275   2              {
 276   3                  if( rs485_4.RX4_rev_cnt > 0 )  
 277   3                  {   
 278   4                       /* 3, 接收完毕标志位亮起并初始化接收缓冲区         */
 279   4                      rs485_4.RX4_rev_end_Flag = 1;    
 280   4                  }
 281   3              }
 282   2          } 
 283   1      
 284   1          /* 1, 如果接收未超时                                             */
 285   1          if ( rs485_5.RX5_rev_timeout != 0 )  
 286   1          {
 287   2              rs485_5.RX5_rev_timeout--;
 288   2              /* 2, 如果接收超时                                          */
 289   2              if( rs485_5.RX5_rev_timeout == 0 )  
 290   2              {
 291   3                  if( rs485_5.RX5_rev_cnt > 0 )  
 292   3                  {   
 293   4                       /* 3, 接收完毕标志位亮起并初始化接收缓冲区         */
 294   4                      rs485_5.RX5_rev_end_Flag = 1;    
 295   4                  }
 296   3              }
 297   2          } 
 298   1      }
 299          
 300          
 301          // void uart2_send_byte( uint8_t byte )
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     08/25/2025 22:37:01 PAGE 6   

 302          // {
 303          //     ES0 = 0;
 304          //     SBUF0 = byte;
 305          //     while (!TI0);
 306          //     TI0 = 0;
 307          //     ES0 = 1;
 308          // }
 309          
 310          // void uart2_send_str( uint8_t *str,uint16_t len )
 311          // {
 312          //     uint16_t i;
 313          
 314          //     for(i=0;i<len;i++)
 315          //     {
 316          //         uart2_send_byte(str[i]);
 317          //     }
 318          // }
 319          
 320          // char putchar(char c)
 321          // {
 322          //     uart2_send_byte(c);
 323          //     return c;
 324          // }
 325          
 326          void press_scan( void )
 327          {
 328   1          uint16_t reg_val = 0; 
 329   1      
 330   1          if( press_flag == 1 )
 331   1          {
 332   2              sys_read_vp(0x2000,(uint8_t*)&reg_val,1);
 333   2      
 334   2              if( reg_val != 0 )
 335   2              {
 336   3                  switch(reg_val)
 337   3                  {
 338   4                      case 1:
 339   4                          LED = 0;
 340   4                          break;
 341   4      
 342   4                      case 2:
 343   4                          LED = 1;
 344   4                          break;
 345   4                          
 346   4                      case 3:
 347   4                          LED = 0;
 348   4                          break;
 349   4      
 350   4                      case 4:
 351   4                          LED = 1;
 352   4                          break;
 353   4                          
 354   4                      default:
 355   4                          break;
 356   4                  }
 357   3      
 358   3                  reg_val = 0;
 359   3                  sys_write_vp(0x2000,(uint8_t*)&reg_val,1);
 360   3              }
 361   2      
 362   2              press_flag = 0;
 363   2          }
C51 COMPILER V9.60.7.0   COMMUNICATION                                                     08/25/2025 22:37:01 PAGE 7   

 364   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    796    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    789       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
