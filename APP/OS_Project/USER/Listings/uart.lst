C51 COMPILER V9.52.0.0   UART                                                              08/22/2025 16:45:05 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN ..\Output\uart.obj
COMPILER INVOKED BY: D:\APP\KEIL_V5\MDK\C51\BIN\C51.EXE ..\HANDWARE\uart.c LARGE OMF2 OPTIMIZE(3,SIZE) BROWSE INCDIR(..\
                    -USER;..\HANDWARE) DEBUG PRINT(.\Listings\uart.lst) TABS(2) OBJECT(..\Output\uart.obj)

line level    source

   1          #include "uart.h"
   2          
   3          RS485 rs485;
   4          u8 p_flag;
   5          
   6          /**
   7           * @brief 串口4调用结构体 rs485 初始化
   8           *
   9           * @param   
  10           *
  11           * @return  void
  12          **/
  13          void Uart2_Send_Statu_Init( void )
  14          {
  15   1          rs485.RX2_rev_end_Flag = 0;
  16   1          rs485.TX2_buf[128] = 0;
  17   1          rs485.RX2_buf[128] = 0;
  18   1          rs485.TX2_send_bytelength = 0;
  19   1          rs485.TX2_send_cnt = 0;
  20   1          rs485.RX2_rev_timeout = 0;
  21   1          rs485.RX2_rev_cnt = 0;
  22   1          //DR_485 = 0;
  23   1      }
  24          
  25          void Uart2_Init( u32 baud )
  26          {
  27   1          MUX_SEL |= 0X40;        //[6] = 1 时，IO口 P0.4、P0.5作为uart2接口
  28   1      
  29   1          P0MDOUT &= 0XCF;        //P0口输出配置
  30   1          P0MDOUT |= 0X10;        //P0.4输出开启，P0.5输出关闭
  31   1      
  32   1          SCON0 = 0x50;           //uart2控制接口，SM1 = 1, REN0 = 1;
  33   1          ADCON = 0x80;           //波特率发生器选择  0x00=T1 定时器，0x80=使用 SREL0H:L。
  34   1          PCON &= 0x7f;           //[7] = 1 时，波特率倍频 为0则不倍频
  35   1      
  36   1          baud = 1024 - (u16)(3225600.0f/baud);
  37   1      
  38   1          SREL0H = (u8)(baud>>8);
  39   1          SREL0L = (u8)baud;
  40   1      
  41   1          ES0 = 1;                //uart2 中断开启
  42   1          EA  = 1;                //总中断开关
  43   1      }
  44          
  45          void Tim0_Init( void )      //1ms
  46          {
  47   1          TMOD &= 0xfc;           //设置为16bit的定时器工作模式
  48   1          TMOD |= 0x00;           //T0_M1 = 0 T0_M0 = 0: 16位自动重装载模式 
  49   1      
  50   1          TH0 = (u8)(T0_PERIOD_1MS>>8);
  51   1          TL0 = (u8)T0_PERIOD_1MS;        
  52   1      
  53   1          ET0 = 1;                //使能中断
  54   1          EA = 1;                 //总中断开关
C51 COMPILER V9.52.0.0   UART                                                              08/22/2025 16:45:05 PAGE 2   

  55   1          TR0 = 1;                //启动T0定时器
  56   1          //TF0 = 0;              //硬件自动清0
  57   1      }
  58          
  59          void Tim1_Init( void )      //1ms
  60          {
  61   1          TMOD &= 0xcf;           //设置为16bit的定时器工作模式
  62   1          TMOD |= 0x00;           //T1_M1 = 0 T1_M0 = 0: 16位自动重装载模式 
  63   1      
  64   1          TH1 = (u8)(T0_PERIOD_1MS>>8);
  65   1          TL1 = (u8)T0_PERIOD_1MS;        
  66   1      
  67   1          ET1 = 1;                //使能中断
  68   1          EA = 1;                 //总中断开关
  69   1          TR1 = 1;                //启动T1定时器
  70   1          //TF1 = 0;              //硬件自动清0
  71   1      }
  72          
  73          void Tim0_Isr( void ) interrupt 1
  74          {
  75   1          static u16 delay_cnt = 0;
  76   1      
  77   1          delay_cnt++;
  78   1      
  79   1          if(delay_cnt == 1000)
  80   1          {
  81   2              p_flag = 1;
  82   2              delay_cnt = 0;
  83   2          }
  84   1      }
  85          
  86          void Tim1_Isr( void ) interrupt 3
  87          {
  88   1          /* 1, 如果接收未超时                                             */
  89   1          if ( rs485.RX2_rev_timeout != 0 )  
  90   1          {
  91   2              rs485.RX2_rev_timeout--;
  92   2              /* 2, 如果接收超时                                          */
  93   2              if( rs485.RX2_rev_timeout == 0 )  
  94   2              {
  95   3                  if( rs485.RX2_rev_cnt > 0 )  
  96   3                  {   
  97   4                       /* 3, 接收完毕标志位亮起并初始化接收缓冲区         */
  98   4                      rs485.RX2_rev_end_Flag = 1;    
  99   4                  }
 100   3              }
 101   2          } 
 102   1      }
 103          
 104          
 105          /**
 106           * @brief 串口4中断处理函数
 107           *
 108           * @param   
 109           *
 110           * @return  void
 111          **/
 112          void Uart2_ISR() interrupt 4 
 113          {   
 114   1      
 115   1          /* 1, 检测到S4TI置1，即发送完毕                       */
 116   1          if( TI0 == 1)          //
C51 COMPILER V9.52.0.0   UART                                                              08/22/2025 16:45:05 PAGE 3   

 117   1          {
 118   2              /* 2, 软件将S4TI清零，等待发送标志位重置，可继续发送    */
 119   2              TI0 = 0;         
 120   2              /* 3, 依次将TX2_buf中数据送出（写SBUF0操作即为发送）    */
 121   2              if( rs485.TX2_send_bytelength != 0 )
 122   2              {
 123   3                  SBUF0 = rs485.TX2_buf[rs485.TX2_send_cnt++];
 124   3                  rs485.TX2_send_bytelength--;
 125   3              }else
 126   2              {
 127   3                  rs485.TX2_send_cnt = 0;
 128   3                  //DR_485 = 0;
 129   3              }
 130   2          }
 131   1          
 132   1          /* 1, 检测到S2RI置1，即接收完毕                       */
 133   1          if( RI0 == 1 )
 134   1          {
 135   2              /* 2, 软件将S2RI清零，等待接收标志位重置，可继续发送    */
 136   2              RI0 = 0;
 137   2              LED = !LED;
 138   2              /* 3, 判断数据包是否接收完毕                           */
 139   2              if( !rs485.RX2_rev_end_Flag )
 140   2              {
 141   3                  /* 4, 数据包大于RX_buf 则从头计数                  */
 142   3                  if( rs485.RX2_rev_cnt > 128 )
 143   3                  {
 144   4                      rs485.RX2_rev_cnt = 0;
 145   4                  }
 146   3      
 147   3                  /* 5, 依次将RX2_buf中数据接收（读S2BUF操作即为接收）*/
 148   3                  rs485.RX2_buf[rs485.RX2_rev_cnt] = SBUF0;
 149   3                  rs485.RX2_rev_cnt++;
 150   3              }
 151   2              /* 6, 重置接收完毕判断时间                              */
 152   2              rs485.RX2_rev_timeout = 5;
 153   2          }
 154   1      }
 155          
 156          void Modbus_Event( void )
 157          {
 158   1          // uint16_t crc,rccrc;
 159   1          
 160   1          /*1.接收完毕                                           */
 161   1          if( rs485.RX2_rev_end_Flag == 1 )
 162   1          {
 163   2              /*2.清空接收完毕标志位                              */    
 164   2              rs485.RX2_rev_end_Flag = 0;
 165   2      
 166   2              // /*3.CRC校验                                         */
 167   2              // crc = MODBUS_CRC16(rs485.RX2_buf, rs485.RX2_rev_cnt-2);
 168   2              // rccrc = (rs485.RX2_buf[rs485.RX2_rev_cnt-1]) | (rs485.RX2_buf[rs485.RX2_rev_cnt-2]<<8);
 169   2      
 170   2              /*4.清空接收计数                                    */
 171   2              rs485.RX2_rev_cnt = 0; 
 172   2              Modbus_Fun6();
 173   2              // /*5.CRC校验通过，进行地址域校验                      */
 174   2              // if( crc == rccrc )
 175   2              // {
 176   2              //     /*6.地址域校验通过，进入相应功能函数进行处理      */
 177   2              //     if( rs485.RX2_buf[0] == 0x01 )
 178   2              //     {
C51 COMPILER V9.52.0.0   UART                                                              08/22/2025 16:45:05 PAGE 4   

 179   2              //         switch ( rs485.RX2_buf[1] )
 180   2              //         {
 181   2              //             case 0x06:
 182   2                              
 183   2              //                 break;  
 184   2      
 185   2              //             default:
 186   2              //                 break;
 187   2              //         }
 188   2              //     }
 189   2              // }
 190   2          }
 191   1      }
 192          
 193          void Modbus_Fun6( void )
 194          {
 195   1          // memcpy(rs485.TX2_buf,rs485.RX2_buf,8);
 196   1      
 197   1          // rs485.TX2_send_bytelength = 8;
 198   1      
 199   1          // TI0 = 1;                              //开始发送
 200   1          // sys_delay_about_ms(1);
 201   1          rs485.TX2_buf[0] = 0x00;
 202   1          rs485.TX2_buf[1] = 0x01;
 203   1          rs485.TX2_buf[2] = 0x02;
 204   1          rs485.TX2_buf[3] = 0x03;
 205   1          rs485.TX2_buf[4] = 0x04;
 206   1          rs485.TX2_buf[5] = 0x05;
 207   1      
 208   1          rs485.TX2_send_bytelength = 6;
 209   1          TI0 = 1;
 210   1      }
 211          
 212          // void uart2_send_byte( u8 byte )
 213          // {
 214          //     ES0 = 0;
 215          //     SBUF0 = byte;
 216          //     while (!TI0);
 217          //     TI0 = 0;
 218          //     ES0 = 1;
 219          // }
 220          
 221          // void uart2_send_str( u8 *str,u16 len )
 222          // {
 223          //     u16 i;
 224          
 225          //     for(i=0;i<len;i++)
 226          //     {
 227          //         uart2_send_byte(str[i]);
 228          //     }
 229          // }
 230          
 231          // char putchar(char c)
 232          // {
 233          //     uart2_send_byte(c);
 234          //     return c;
 235          // }
 236          
 237          
 238          /**
 239           * @brief crc校验函数
 240           * 
C51 COMPILER V9.52.0.0   UART                                                              08/22/2025 16:45:05 PAGE 5   

 241           * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
 242           * @param   length:数据长度           
 243           * 
 244            @return  crc16:crc校验的值 2byte
 245           */
 246          uint16_t MODBUS_CRC16(uint8_t *buf, uint8_t length)
 247          {
 248   1        uint8_t i;
 249   1        uint16_t  crc16;
 250   1      
 251   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
 252   1        crc16 = 0xffff; 
 253   1      
 254   1        do
 255   1        {
 256   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */    
             -    
 257   2          crc16 ^= (uint16_t)*buf;    //
 258   2          for(i=0; i<8; i++)    
 259   2          {
 260   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位 再异或0xA001    */
 261   3            if(crc16 & 1)
 262   3                  {
 263   4                      crc16 = (crc16 >> 1) ^ 0xA001;
 264   4                  }
 265   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位                */
 266   3                  else
 267   3                  {
 268   4                      crc16 >>= 1;
 269   4                  }   
 270   3          }
 271   2          buf++;
 272   2        }while(--length != 0);
 273   1      
 274   1        return  (crc16);
 275   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    637    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    266      11
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
